---
title: "Bioconductor Overview: edX 525.5x Part I"
author: "Vincent J. Carey"
package: edx2017.5x
output: 
  BiocStyle::html_document2:
    toc: true
    toc_float: true
abstract: >
  This document introduces concepts to be covered in the 5x module,
  *Introduction to Bioconductor*.  This overview document covers six
  key concepts: R language and packages, the central dogma of molecular
  biology, genome-scale assays, data structures for such assays,
  exploratory analysis, and hypothesis testing.  Our objective with
  this document is to
  ensure acquaintance with the higher-level concepts of the
  submodules to follow, with very light sketches of code in
  R that can be used to get some hands-on exposure to these
  concepts.  Some of the technical material on package
  structure and continuous integration can be safely skipped.
vignette: >
  %\VignetteIndexEntry{Bioc overview Part I}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---
```{r setup,echo=FALSE,results="hide"}
suppressWarnings({
suppressPackageStartupMessages({
library(png)
library(grid)
library(Homo.sapiens)
library(GenomicRanges)
library(BSgenome.Hsapiens.UCSC.hg19)
library(RNAseqData.HNRNPC.bam.chr14)
library(GenomicAlignments)
library(Rsamtools)
library(ggbio)
})
})
```

# The R language and its packages and repositories

This course assumes a good working knowledge of the R language.
The Rstudio environment is recommended.  If you want to
work through a tutorial before proceeding, 
[Try R](http://tryr.codeschool.com/) is very comprehensive.

## Why R?

Bioconductor is based on [R](www.r-project.org).  Three key reasons for this are:

- R is used by many statisticians and biostatisticians to create algorithms that advance our ability to understand complex experimental data.
- R is highly interoperable, and fosters reuse of software components written in other languages. 
- R is portable to the key operating systems running on commodity computing equipment (Linux, MacOSX, Windows) and can be used immediately by beginners with access to any of these platforms.

In summary, R's ease-of-use and central role in statistics and "data science" make it a natural choice for a tool-set for use by biologists and statisticians confronting genome-scale experimental data.  Since the Bioconductor project's inception in 2001, it has kept pace with growing volumes
and complexity of data emerging in genome-scale biology.

## Functional object-oriented programming

R combines functional and object-oriented programming paradigms.^[[Chambers 2014](https://projecteuclid.org/euclid.ss/1408368569)]

- In functional programming, notation and program activity mimic the
concept of function in mathematics.  For example
```
square = function(x) x^2
```
is valid R code that defines the symbol `square` as a function that
computes the second power of its input.  The body of the function
is the program code `x^2`, in which `x` is a "free variable".
Once `square` has been defined in this way, `square(3)` has
value `9`.  We say the `square` function has been evaluated on
argument `3`.  **In R, all computations proceed by evaluation of functions.**

- In object-oriented programming, a strong focus is placed upon
formalizing data structure, and defining methods that take
advantage of guarantees established through the formalism.  This
approach is quite natural but did not get well-established in
practical computer programming until the 1990s.  As an
advanced example with Bioconductor, we will consider an 
approach to defining an "object" representing on the genome
of *Homo sapiens*:
```{r lkho}
library(Homo.sapiens)
class(Homo.sapiens)
methods(class=class(Homo.sapiens))
```
We say that `Homo.sapiens` is an **instance** of the `OrganismDb` **class**.  Every instance of this class must respond to the methods
listed above.  Of special note at this juncture are the methods
`genes`, `exons`, `transcripts` which will yield information about
fundamental components of genomes used to devise and interpret
molecular assays.  These methods will succeed for human and
for other model organisms such as *Mus musculus*, *S. cerevisiae*,
*C. elegans*, and others for which the Bioconductor project and its contributors have defined `OrganismDb` representations.

## R packages, modularity, continuous integration

This section can be skipped on a first reading.

### Package structure

We can perform object-oriented functional programming with R
by writing R code.  A basic approach is to create "scripts" that
define all the steps underlying processes of data import and
analysis.  When scripts are written in such a way that they
only define functions and data structures, it becomes possible to
*package* them for convenient distribution to other users
confronting similar data management and data analysis problems.

The R software [packaging protocol](https://cran.r-project.org/doc/manuals/r-release/R-exts.html) specifies how source code in R and other languages can be organized together with metadata and documentation to foster
convenient testing and redistribution.  For example, an early
version of the package defining this document had the folder 
layout given below:

```
├── DESCRIPTION  (text file with metadata on provenance, licensing)
├── NAMESPACE    (text file defining imports and exports)
├── R            (folder for R source code)
├── README.md    (optional for github face page)
├── data         (folder for exemplary data)
├── man          (folder for detailed documentation)
├── tests        (folder for formal software testing code)
└── vignettes    (folder for high-level documentation)
    ├── biocOv1.Rmd
    ├── biocOv1.html
    └── wikiCentralDogma.png
```

The packaging protocol document "Writing R Extensions" provides
full details.  The R command `R CMD build [foldername]` will operate on the
contents of a package folder to create an archive that can
be added to an R installation using `R CMD INSTALL [archivename]`.
The R studio system performs these tasks with GUI elements.

### Modularity and formal interdependence of packages

The packaging protocol helps us to isolate software that
performs a limited set of operations, and to
identify the **version** of a program collection
that is inherently changing over time.  There is
no objective way to determine whether
a set of operations is the right size for packaging.
Some very useful packages carry out only a small number of
tasks, while others have very broad scope.  What is important
is that the package concept permits **modularization** of
software.  This is important in two dimensions: scope and time.
Modularization of scope is important to allow parallel independent
development of software tools that address distinct problems.
Modularization in time is important to allow identification of
versions of software whose behavior is stable.

### Continuous integration: testing package correctness and interoperability

The figure below is a snapshot of the [build report](http://bioconductor.org/checkResults/3.6/bioc-LATEST/) for the development branch of Bioconductor.

```{r lkci,fig=TRUE,echo=FALSE,fig.wide=TRUE, fig.cap="Continuous integration report for Bioconductor devel branch.  All packages are checked every night on three major computing platforms."}
im = readPNG("buildRep.png")
grid.raster(im)
```


## Putting it together

Bioconductor's core developer group works hard to develop
data structures that allow users to work conveniently with
genomes and genome-scale data.  Structures are devised to
support the main phases of experimentation in genome scale biology:

- Parse large-scale assay data as produced by microarray or sequencer flow-cell scanners.
- Preprocess the (relatively) raw data to support reliable statistical interpretation.
- Combine assay quantifications with sample-level data to test hypotheses about relationships between molecular processes and organism-level characteristics such as growth, disease state.

In this course we will review the objects and functions that
you can use to perform these and related tasks in your own
research.

# The central dogma of molecular biology restated

Very simply, the central dogma states that DNA makes RNA makes
protein.  This, combined with the idea that cellular activities
are primarily driven by protein chemistry, motivates our
agenda.  DNA sequences are blueprints for protein collections,
but the path from DNA to functional protein and beyond,
to organismic structure and function, is long and
incompletely understood.

More detail is exposed in the following diagram.

```{r lklk,fig=TRUE,echo=FALSE,fig.wide=TRUE, fig.cap="Wikipedia schematic.  Chromosomes are composed of coding and non-coding DNA sequence.  Coding sequence includes exons and introns.  Exons are spliced and transcribed to messenger RNA (mRNA), which is then processed and translated to active protein."}
im = readPNG("wikiCentralDogma.png")
grid.raster(im)
```

In the past 10 years, many facets of the central dogma have
started to come into focus.  We will learn how to work with
data on DNA sequence, mRNA, and other genomic entities to
test hypotheses on biological processes (often in
the form of human diseases).  In this way we will strengthen
mankind's understanding of human health and the mechanisms
by which medical practices work to preserve health, and restore it 
when it has been lost.

# A collection of genome-scale assays

## The complete DNA sequence for an organism's reference genome

The figure below is a snapshot of use of the UCSC genome
browser, providing nucleotide-level depiction of sequence
and annotation for an expressed part of the gene ORMDL3.

```{r lkbrow,fig=TRUE,echo=FALSE,fig.wide=TRUE, fig.cap="DNA sequence and annotation for gene ORMDL3. This is a gene on chromosome 17 suspected of playing a role in the development of asthma."}
im = readPNG("ucscORMDL3.png")
grid.raster(im)
```

The sequence of letters ACTG along the top of the display are the
reference base calls for the human genome.  We will use Bioconductor
object to extract these in R, to illustrate 
the object-oriented programming concept noted above.

### An object representing a reference build of the human genome

The `BSgenome.Hsapiens.UCSC.hg19` package provides a representation
of the reference genome created at NCBI in 2009.  Individual
chromosomes (or more generally, annotated contiguous sequences,
some of which have yet to be positioned on chromosomes) can
be referenced using the `$` operator.
```{r lkhg}
library(BSgenome.Hsapiens.UCSC.hg19)
Hsapiens
Hsapiens$chr1
```

### A 'range' object identifying a set of genomic coordinates

The `GenomicRanges` package defines a family of data structures
useful for representing intervals on sequences.  A `GRanges`
instance can represent the coding region of a gene by defining
the name of the chromosome, the start and end positions of
the gene region, the strand on which the
gene resides, and the reference genome for which gene location
was determined.  Here we define the extent of coding
region for ORMDL3.
```{r dog}
library(GenomicRanges)
myr = GRanges("chr17", 
    IRanges(38077296, 38083884), strand="-", genome="hg19")
myr
```

### A request for nucleotide sequence

The nucleotide sequence for any interval is acquired
with the `getSeq` in the `Biostrings` package.
```{r doget}
getSeq(Hsapiens, myr)
```

## SNPs: cataloging population-level variation in DNA sequence

[the 'SNPs in publications' glyph](https://genome.ucsc.edu/cgi-bin/hgc?c=chr17&l=38082721&r=38082892&o=38082806&t=38082807&g=pubsMarkerSnp&i=rs12603332&db=hg19)

## mRNA abundance estimates: depicting transcriptional states

The abundance of 
messenger RNA (mRNA) molecules in cells can be quantified
in various ways.  In general it is not possible to
obtain exact counts, but relative abundances 
are compared between samples after extensive
statistical preprocessing.  The overall process of
assaying single or multiple cells for mRNA abundance
is sometimes referred to as transcript profiling.

High-throughput sequencing of mRNA
(RNA-seq) has become the most common method
of measurement for current studies, but a large
archive of mRNA measurements obtained using
DNA microarrays is available at NCBI Gene Expression
Omnibus (GEO) and is useful for retrospective research.
We will examine both modalities of transcriptome
measurement, but for this introduction we focus
on RNA-seq.

### HNRNPC: a gene that may protect us from defective mRNA splicing

A 2013 paper of [Zarnack and colleagues](http://dx.doi.org/10.1016/j.cell.2012.12.023)
studies the role of the heterogeneous nuclear ribonucleoproteins C1 and C2
(coded for by gene HNRNPC) in the prevention of inclusion of cryptic Alu elements
in spliced transcripts.  One part of the study involves knockdown of HNRNPC
in HeLa cells, followed by genome-wide observation of frequency of cryptic Alu element
inclusion.  

The Bioconductor package `RNAseqData.HNRNPC.bam.chr14` includes an extract
from the RNA-seq data generated in this study.  There are 8 BAM files that have
been filtered and indexed to include information on mRNA molecules mapped
to the sequence of chromosome 14.  The protocol creates "paired-end" reads.
We can have a quick look at the short reads of mRNA sequence as follows:

```{r getlibs}
bf1 = RNAseqData.HNRNPC.bam.chr14_BAMFILES[1] # first of 8 files in package
r1 = readGappedReads(bf1)
r1[1:5]
qseq(r1[1:5])
```

We can demonstrate the detectability of mRNA coded for by HNRNPC
using the plotting package `ggbio`.  We use our knowledge of the location
of the gene to set up a scanning parameter to focus the data extract.
```{r domo,fig=TRUE,fig.height=4}
library(Rsamtools)
library(ggbio)
hnrnpc_param = ScanBamParam(which=GRanges("chr14", IRanges(21.67e6,21.74e6)))
limr1 = readGappedReads(bf1, param=hnrnpc_param, use.names=TRUE)
autoplot(limr1, geom="line", stat="coverage") + ylim(0,900)
```

Later we will examine data from the knocked-down samples and examine
the pairing of reads in more detail.

<!-
pr1 = readGAlignmentPairs(bf1, param=ScanBamParam(what="seq"))
-->

## Epigenomics: how regulatory factors bind to DNA to control transcription and translation

## Other crucial assay classes: Proteomics, metabolomics, microbiomics, whole-genome editing

## Coda: the single cell revolution

# Data structures for genome-scale assays

# Exploring genome-scale assay data

# Testing statistical hypotheses with genome-scale assays

